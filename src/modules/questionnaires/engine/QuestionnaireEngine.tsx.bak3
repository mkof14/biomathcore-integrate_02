"use client";
import { useEffect, useMemo, useRef, useState } from "react";
import type { CompiledItem, MetricMode, ModuleConfig, QuestionnaireState, Question } from "../types";

type Props = {
  modules: ModuleConfig[];
  initialMetric?: MetricMode;
  storageKey?: string;
  onSubmit?: (payload: { answers: Record<string, string|number>; metricMode: MetricMode }) => Promise<void> | void;
};

function flatten(mods: ModuleConfig[]): CompiledItem[] {
  const items: CompiledItem[] = [];
  for (const m of mods) for (const q of m.questions) items.push({ moduleKey: m.key, q });
  return items;
}

function isAnswered(q: Question, v: unknown): boolean {
  if (q.type === "text") return typeof v === "string" && v.trim().length > 0;
  if (q.type === "select") return typeof v === "string" && v.length > 0;
  if (q.type === "scale") return typeof v === "number";
  return false;
}

export default function QuestionnaireEngine({ modules, initialMetric = "percent", storageKey = "bmc.qna", onSubmit }: Props) {
  const [state, setState] = useState<QuestionnaireState>(() => {
    if (typeof window !== "undefined") {
      const raw = localStorage.getItem(storageKey);
      if (raw) { try { return JSON.parse(raw) as QuestionnaireState; } catch {} }
    }
    return { metricMode: initialMetric, answers: {}, currentIndex: 0 };
  });

  const savingRef = useRef<number | null>(null);
  useEffect(() => {
    if (typeof window === "undefined") return;
    if (savingRef.current) cancelAnimationFrame(savingRef.current);
    savingRef.current = requestAnimationFrame(() => {
      localStorage.setItem(storageKey, JSON.stringify(state));
    });
  }, [state, storageKey]);

  // Flatten with skip-logic: remove sexual health items if consent=no
  const compiled = useMemo(() => {
    const items = flatten(modules);
    const consent = state.answers["sh.consent"];
    if (consent === "no") {
      return items.filter(it => !it.q.id.startsWith("sh.") || it.q.id === "sh.consent");
    }
    return items;
  }, [modules, state.answers]);

  const total = compiled.length;
  const requiredTotal = useMemo(() => compiled.filter(i => !!i.q.required).length, [compiled]);
  const answeredRequired = useMemo(() => {
    let count = 0;
    for (const it of compiled) {
      if (!it.q.required) continue;
      const v = state.answers[it.q.id];
      if (isAnswered(it.q, v)) count++;
    }
    return count;
  }, [compiled, state.answers]);

  const current = compiled[state.currentIndex] ?? null;

  const progressOverall = total ? Math.round(((state.currentIndex + 1) / total) * 100) : 0;
  const progressRequired = requiredTotal ? Math.round((answeredRequired / requiredTotal) * 100) : 100;

  function setAnswer(id: string, value: string | number) {
    setState(s => ({ ...s, answers: { ...s.answers, [id]: value } }));
  }

  function next() {
    if (current?.q?.required) {
      const v = state.answers[current.q.id];
      if (!isAnswered(current.q, v)) return;
    }
    setState(s => ({ ...s, currentIndex: Math.min(s.currentIndex + 1, total - 1) }));
  }
  function prev() {
    setState(s => ({ ...s, currentIndex: Math.max(s.currentIndex - 1, 0) }));
  }
  function toggleMetric() {
    setState(s => {
      const order: MetricMode[] = ["percent","score","level"];
      const i = order.indexOf(s.metricMode);
      const next = order[(i+1) % order.length];
      return { ...s, metricMode: next };
    });
  }

  const currentRequiredUnanswered = (() => {
    if (!current?.q?.required) return false;
    const v = state.answers[current.q.id];
    return !isAnswered(current.q, v);
  })();

  const canSubmit = requiredTotal === 0 || answeredRequired === requiredTotal;

  async function handleSubmit() {
    if (!canSubmit) return;
    if (onSubmit) await onSubmit({ answers: state.answers, metricMode: state.metricMode });
  }

  function renderQuestion(q: Question) {
    if (q.type === "text") return (
      <input type="text" placeholder={q.placeholder || ""} value={(state.answers[q.id] as string) || ""}
        onChange={(e: any) => setAnswer(q.id, e.target.value)} className="w-full" aria-required={!!q.required}/>
    );
    if (q.type === "select") return (
      <select value={(state.answers[q.id] as string) || ""} onChange={(e: any) => setAnswer(q.id, e.target.value)}
        className="w-full" aria-required={!!q.required}>
        <option value="" disabled>{q.required ? "Select an option *" : "Select an option"}</option>
        {q.options.map(o => <option key={o.value} value={o.value}>{o.label}</option>)}
      </select>
    );
    return (
      <div>
        <input type="range" min={q.min} max={q.max} step={q.step || 1}
          value={Number(state.answers[q.id] ?? q.min)} onChange={(e: any) => setAnswer(q.id, Number(e.target.value))}
          className="w-full" aria-required={!!q.required}/>
        <div className="flex justify-between text-xs opacity-80">
          <span>{q.leftLabel ?? q.min}</span>
          <span>{q.rightLabel ?? q.max}</span>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full">
      <div className="mb-2">{progressOverall}%</div>
      <div className="mb-4">Required: {progressRequired}%</div>
      <div className="mb-4"><button type="button" onClick={toggleMetric}>Metric: {state.metricMode}</button></div>
      {current ? (
        <div className="mb-4">
          <div className="mb-2 font-semibold">{current.q.label}{current.q.required ? " *" : ""}</div>
          {renderQuestion(current.q)}
          {currentRequiredUnanswered && <div className="mt-2 text-xs" role="alert">This field is required.</div>}
        </div>
      ) : <div>No questions</div>}
      <div className="flex gap-2">
        <button type="button" onClick={prev} disabled={state.currentIndex === 0}>Back</button>
        <button type="button" onClick={next} disabled={currentRequiredUnanswered || state.currentIndex >= total - 1}>Next</button>
        <button type="button" onClick={handleSubmit} disabled={!canSubmit}>Submit</button>
      </div>
    </div>
  );
}
